---
cssclasses:
  - purpleRed
  - wideTable
  - fixedRf
---

Il modo più semplice e immediato di organizzare le fasi del ciclo di vita di un software è sicuramente quello **sequenziale**: viene posto un ordine in cui i passaggi vengono attraversati uno alla volta. Da questa idea nascono i cosiddetti *modelli sequenziali*, di cui il più famoso è il **modello a cascata**.

## Modello a cascata
---
### Caratteristiche e punti di forza
---

![[assets/waterfall_model.png]]


Nasce negli anni '50, ma diventato famoso solo negli anni '70 grazie allo sviluppo di un grosso software per la difesa chiamato SAGE (*Semi-Automated Ground Environment*), il modello a cascata organizza le fasi in una serie di step sequenziali: fatto uno si passa al successivo fino ad arrivare alla fine, come in una sorta di *catena di montaggio*. Viene, infatti, forzata una **progressione lineare** da una fase alla successiva; non è previsto in questo modello tornare indietro a uno step precedente.

Sebbene varino molto da processo a processo, la maggior parte dei processi che segue il modello a cascata include almeno le seguenti fasi organizzate in quest'ordine:

1. Requisiti
2. Progetto
3. Codifica
4. Testing
5. Prodotto

Ogni step produce un output, detto **semilavorato**, che è dato come input allo step successivo. In virtù dell'affidamento su tali semilavorati intermedi, il modello a cascata si dice **document-based**: tra una fase e l'altra si crea infatti un documento che è il mezzo di trasmissione dell'informazione. Questo aspetto permette una **buona separazione dei compiti** tra i vari dipendenti che lavorano al progetto: poiché ognuno sarà specializzato in una singola fase e una volta prodotto il documento utile ad avviare la fase successiva il suo coinvolgimento nel progetto non è più necessario, ed esso può essere assegnato ad altri lavori. Questo modello, come si può intuire, ha introdotto un certo rigore che fino ad allora non si era ancora visto nel mondo dello sviluppo software, dando importanza anche alla documentazione del lavoro.

La linearità del modello rende, inoltre, possibile **pianificare i tempi** accuratamente e monitorare semplicemente lo stato di avanzamento in ogni fase: è sufficiente stimare la durata di ogni fase per ottenere una stima del tempo di completamento dell'intero progetto. Si tratta, però, di una stima a senso unico: una volta finita una fase NON è possibile ridurre il tempo speso, e in caso di inconvenienti l'unica opzione è cercare di assorbire il ritardo.

### Criticità
---

Sebbene il modello a cascata abbia il grande pregio di aver posto l'attenzione sulla comunicazione tra gli elementi del progetto in un momento storico in cui il modello di sviluppo più diffuso era di tipo *code-and-fix*, esso soffre di **numerose criticità**, le cui più importanti sono:

- **Mancanza di una fase di manutenzione**, in quanto **non è prevista una fase di manutenzione** del software prodotto: esso assume di non dover apportare modifiche al progetto dopo averlo consegnato, e impedisce dunque la possibilità di "tornare indietro". Ovviamente, questa assunzione è un'illusione smentita nella quasi totalità dei casi: qualunque software è destinato ad evolvere, e più un software viene usato più cambia. Una volta finito lo sviluppo, ciò che si può fare è **rilasciare al più piccole patch**, che tuttavia non fanno altro che disallineare la documentazione prodotta precedentemente con il software reale;

- **Generale rigidità**, che mal si sposa con la flessibilità naturalmente richiesta dall'ambiente di sviluppo software. In particolare, l'impossibilità di tornare indietro implica un **congelamento dei sottoprodotti**: una volta prodotto un semilavorato, esso è e rimarrà immutabile; questo è particolarmente critico per le stime e le specifiche fatte durante le prime fasi, che sono fisiologicamente le più incerte;

- **Approccio di tipo monolitico**, tutta la pianificazione è orientata ad un singolo rilascio, e l'eventuale manutenzione può essere fatta solo sul codice. Inutile dire che si tratta di una visione fallace, in quanto come già detto più volte il software è destinato ad essere modificato e ad evolvere.

### *Who's Afraid of the Big Bad Waterfall?*
---

> LIBRO: **The Leprechauns of Software Engineeering** di Laurent Bossavit.

In realtà, il modello a cascata non è mai stato veramente elogiato, ma è sempre stato utilizzato come **paragone negativo** per proporre altri modelli o variazioni. Nel corso del tempo la sua presentazione è stata erroneamente attribuita al paper [*“Managing the development of large software systems: concepts and techniques”*](https://dl.acm.org/doi/10.5555/41765.41801) di W.W. Royce, di cui veniva citata solo la prima figura: Royce stava, a dire il vero, presentando quel modello per descrivere la sua esperienza nello sviluppo software, per poi proporre altri concetti più moderni, che non sono però mai stati colti dalla comunità scientifica.

Anche noi utilizziamo il modello a cascata solo come paragone negativo, ed in generale nell'ambiente di sviluppo software esso non viene più applicato nella sua interezza. Alcuni suoi aspetti si sono però mantenuti come linee guida generali; infatti, è bene chiarire subito che esistono due tipi di modelli:

- prescrittivi, forniscono delle indicazioni precise da seguire per svolgere un processo;
- descrittivi, colgono certi aspetti e caratteristiche di particolari processi esistenti, ma non obbligano a seguirli in modo rigoroso.

### Riassunto pro e contro
---

| Pro                                                                                                                                           | Contro                                                                                                             |
| --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| <ul><br><li>**Document-based**</li><br><li>**Buona suddivisione dei compiti**</li><br><li>**Semplice pianificazione dei tempi**</li><br></ul> | <ul><br><li>**Rigidità**</li><br><li>**Congelamento dei sottoprodotti**</li><br><li>**Monoliticità**</li><br></ul> |

## Modello a V (denti di pesce cane)
---

![[v_model.png]]

Partendo dal modello a cascata, sono nati poi numerose varianti che ne hanno cercato di risolverne i problemi: tra queste, spicca per rilevanza il *modello a V*, che introduce fondamentalmente una **più estesa fase di testing**.

Nonostante si tratti comunque di un modello a sequenziale (come quello a cascata), nel modello a V vengono delineati nuovi legami tra le fasi di sviluppo, che corrispondono alle attività di **verifica e convalida**: alla fine di ogni fase si *verifica* che il semilavorato ottenuto rispetti la specifica espressa dalla fase precedente, e si richiede la *convalida* del fatto che esso sia in linea con i veri vincoli e necessità del cliente. Il modello pone particolare importanza sul rapporto con il cliente, che viene continuamente coinvolto con la richiesta di feedback su ciascun sottoprodotto generato. Inoltre, ogni fase include delle "frecce implicite" dirette verso sé stessa, indicando la necessità di una verifica per garantire la coerenza logica del risultato prodotto.

Volendo formalizzare, le due nuove attività introdotte sono:

- **verifica** (frecce bianche), controlla la correttezza rispetto alla descrizione formale delle specifiche;
- **convalida** (frecce grigie), controlla la compatibilità del sistema con le esigenze del cliente tramite feedback continuo.