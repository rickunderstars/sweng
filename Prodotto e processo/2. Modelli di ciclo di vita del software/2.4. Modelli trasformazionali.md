![[transf_models.png]]

Diametralmente opposti all’incubo del Pinball Life-Cycle troviamo i **modelli trasformazionali**. Tali modelli pretendono, infatti, di controllare tutti i passi e i procedimenti in **modo formale** e di estremizzare il numero di incrementi.

Partendo dai requisiti scritti in linguaggio informale, tali modelli procedono tramite una sequenza di **passi di trasformazione** dimostrabili tutti formalmente fino ad arrivare alla versione finale. Essi si basano infatti sull’idea che se le specifiche sono corrette e i passi di trasformazione sono dimostrati, allora ottengo un programma corretto, ovvero sicuramente aderente alle specifiche di cui sopra.
La presenza di una **storia delle trasformazioni applicate** permette un **rudimentale versioning**, con la **possibilità di tornare indietro a uno stato precedente** del progetto semplicemente annullando le ultime trasformazioni fatte.

![[formal_transformation.png]]

Ad ogni passo si ottiene quindi un **prototipo** che differisce dal prodotto finale per *efficienza* e *completezza*, ma che è possibile trasformare in un altro più efficiente e corretto. Non si tratta, tuttavia, di un processo totalmente automatico, in quanto ad ogni passo di *ottimizzazione* (ovvero applicazione di una trasformazione) è richiesto l’intervento di un decisore umano che scelga che cosa ottimizzare.

Viene quindi introdotto il concetto di **prova formale di correttezza** delle trasformazioni applicate. A causa di questo approccio molto rigido, questi modelli sono applicati nella realtà quasi solo negli ambienti di ricerca, oppure in progetti che includono sia hardware che software, come ad esempio lo sviluppo di processori.

## *Meta*modello a spirale
---

![[spiral_metamodel.png]]

Introduciamo ora un **metamodello**, ovvero un modello che ci permette di rappresentare e discutere di altri modelli (una sorta di framework).

Nel *metamodello a spirale*, l’attenzione è posta sui **rischi** (_risk based_), ovvero sulla possibilità che qualcosa vada male. Per questo motivo, il modello è di **tipo incrementale** e pone particolare importanza sul fatto che non abbia senso fare lo studio di fattibilità una sola volta, ma ad ogni iterazione serve una decisione.

Le fasi generali sono dunque:

- Determinazione di obiettivi, alternative e vincoli
- Valutazione di alternative, identificazione rischi (decido se ha senso andare avanti)
- Sviluppo e verifica
- Pianificazione della prossima iterazione

Nella figura sopra riportata, il raggio della spirale indica i **costi**, che ad ogni iterazione aumentano fisiologicamente. Questo metamodello porterà alla possibilità di scegliere la via iterativa o quella incrementale in base alle esigenze del progetto.

### Variante "*win-win*"
---

![[spiral_metamodel_winwin.png]]

Esiste una variante del modello a spirale che fa notare come i rischi ad ogni fase non sono solo rischi tecnologici, ma anche **contrattuali**, con il cliente.
Ad ogni iterazione bisogna, dunque, trovare con esso un **punto di equilibrio** (_win-win_) in cui entrambi le parti “vincono” (o hanno l’illusione di aver vinto), così da far convergere tutti su un obiettivo comune.

## Modello COTS (*Component Off The Shelf*)
---

![[cots_model.png]]

Vediamo, infine, un modello che si concentra molto sulla **riusabilità**. Si parte dalla disponibilità interna o sul mercato di moduli preesistenti sui quali basare il sistema, e che è dunque necessario solo integrare tra di loro.

**Non si tratta**, nonostante si possa nutrire quest'impressione, **di un approccio facile**, in quanto questo modello necessita un dialogo tra componenti che non necessariamente comunicano già nel modo voluto.

Si tratta, tuttavia, di un modello di sviluppo diverso, poiché richiede attività diverse. In particolare:

- ***Analisi dei requisiti***;
- _**Analisi dei componenti**_, in quanto prima di progettare si va a considerare la disponibilità di componenti che implementano una parte o tutte le funzionalità richieste;
- _**Modifica dei requisiti**_, in cui si stabilisce se il cliente sia disposto ad accettare un cambiamento nei requisiti necessario per utilizzare un componente particolare;
- _**Progettazione del sistema col riuso di componenti**_, in cui si va a progettare un sistema per far interagire componenti che non necessariamente sono stati progettati per farlo;
- **_Sviluppo e integrazione**_;
- **_Verifica del sistema_**.

I lati positivi di questo approccio risiedono nel fatto che **non bisogna sviluppare tutto da zero**, ma **vengono utilizzate delle componenti già esistenti**. D’altra parte, nel caso in cui il numero di componenti sia troppo elevato, il lavoro di adattamento sarà molto complesso e le funzionalità non necessarie di quest’ultime andranno ad inficiare sul risultato finale del progetto, diminuendone ad esempio l’efficienza (ad esempio importare librerie intere quando servono solo alcune componenti da suddette librerie).

## Sviluppi futuri
---
Oggi, lo sviluppo delle intelligenze artificiali sta facendo enormi passi in avanti, basti vedere lo sviluppo di strumenti come ChatGPT o Copilot, che stanno rivoluzionando il mondo dell’informatica.
Negli anni a venire, sicuramente giocheranno un ruolo importante anche nella gestione del processo produttivo di un software, ma ad oggi non sono ancora utilizzate pienamente in ambito aziendale.