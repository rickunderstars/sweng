# Di cosa si occupano
---
Gli SCM **non dipendono da linguaggi di programmazione** poiché questi lavorano su file, andando a considerarne soltanto le righe di testo, ignorando quindi se si tratti di codice, un'immagine o altri formati.
Un’eccezione è *Monticello*, che consiste in un intero ambiente di sviluppo per il *linguaggio Smalltalk*, contenente un tool di versioning creato appositamente per questo linguaggio.

Ogni cambiamento è regolato da:

- **check-out**, viene dichiarata la volontà di lavorare partendo da una particolare revisione di un manufatto (o di una configurazione di diversi manufatti);
- **check-in** (o **commit**), viene dichiarata la volontà di registrare una nuova versione (spesso chiamata change-set).

Queste operazioni vengono attivate rispetto a un _repository_ (che contiene tutte le configurazioni) con cui il workspace (l’ambiente in cui si trova nel filesystem) avrà uno scambio di dati.

Solitamente ho **un repository** e **n workspace**, uno per ogni ambiente dove sto lavorando.

## Repository
---
I repository mantengono date, etichette, versioni, diramazioni (*branches*) e altri dati. Per risparmiare spazio, i repository salvano solo le differenze tra una versione e l’altra.
In realtà, Git non fa così, perché usa *link simbolici*: fare il _checkout_ di una specifica versione è **istantaneo**.

I repository possono essere centralizzate o distribuite. Nei sistemi di versioning distribuiti c’è il concetto di **hashing**, in modo da identificare file uguali anche se in posizioni diverse.
Per confrontare storie diverse si utilizzano gli hash dei file e delle directory.

### Accesso concorrente
---
Quando il repository è condiviso da un gruppo di lavoro nasce il problema di gestirne l’accesso concorrente. Esistono due modelli:

- **modello _‘pessimistico’_** (*RCS*), viene previso il possibile conflitto e ci assicura che chi ci lavora sia l’unico con l’accesso in scrittura. Funziona **solo in ambienti centralizzati**, nell’open source non può funzionare.
- **modello _‘ottimistico’_** (*CVS*), il sistema si disinteressa del problema e fornisce supporto per le attività di _merge_ di change-set paralleli potenzialmente conflittuali.

Il modello ottimistico può essere regolato con i **branch**: l’attività di _merge_ è, quindi, fondamentale.

CVS/Subversion scoraggiava i branch, ma Git li ha resi più facili e incoraggiandone l'uso.
In Git, l’uso dei branch è talmente comune che a volte è necessario introdurre delle politiche (es. *GitFlow*) sul loro utilizzo.

## Cosa tracciare
---
Capire cosa sia necessario tracciare o meno in un progetto non è semplice: sicuramente, devono essere tracciati **tutti i file relativi al codice sorgente** o **file di configurazione**, ma per quanto riguarda il resto **non c’è una risposta precisa**, in quanto **dipende dalle necessità**.
In linea di massima, occorre prendere due decisioni importanti che influenzano la **replicabilità** della produzione, ovvero:

- Si traccia l’evoluzione dei componenti fuori dal nostro controllo (es. compilatori, librerie)?
- Si archiviano i file che costituiscono il prodotto (es. file generati come file binari)?

Solitamente, la risposta a queste due domande è **no**.
Tracciare le librerie o i binari del software è costoso e poco pratico, ma così facendo la perfetta replicabilità va perduta. Infatti, è possibile che alcuni software con il passare del tempo non possano essere eseguiti in quanto le tecnologie necessarie al loro funzionamento potrebbero non essere più disponibili.
C’è da dire però che, se un progetto viene mantenuto costantemente, la sua vita viene allungata di conseguenza. A volte può avere senso fare versioning dei file generati, infatti è possibile distribuire le diverse versione tramite _‘package’_.
Su alcuni siti come GitHub o GitLab ci sono delle sezioni, diverse da quelle dove viene messo il codice, dedicate alla pubblicazione di questi package, ma questo non è un vero e proprio versioning come viene fatto per il codice tramite git (non vi è una storia modificabile, ma solo una **serie di versioni del software**).
