![[git_command_scheme.png]]

In figura si possono osservare 4 _livelli_ ordinati:

- **working directory** (*WD*), rappresenta la _configurazione_ della directory di lavoro sul filesystem, esiste indipendentemente da git. Può essere vista come l’unione dei _tracked_ and _untracked_ files;
- **index** (o **area di staging**), l'insieme dei _tracked_ files da git;
- ($n$) **local repository**, l'insieme delle modifiche di cui si è eseguito il **commit** e relativo storico;
- ($m$) **remote repository**, *branch remoto*; è possibile avere sia più branch per progetto remoto che più progetti remoti configurati.

Il termine _**repository**_ è abbastanza fuorviante in questo conteso, poiché comunemente associato ad un progetto, mentre in questa astrazione a livelli corrisponde di fatto a un **branch**.

Il passaggio tra un livello e l’altro non è mai automatico, ma è sempre esplicitato da un’operazione.

# Operazioni di base
---
![[git_structure.png]]

Per ogni branch c’è un puntatore all’ultimo commit di tale branch.
L’**HEAD** punta all’ultimo commit in cui siamo: normalmente corrisponde al puntatore del branch corrente; quando non è così, siamo in una situazione di _HEAD scollegato_.
È utile potersi spostare tra i commit per controllare revisioni precedenti, ma in caso di nuovi commit è importante creare un nuovo branch per poterci riferire ad esse.

È consigliata la lettura di [git Cheatsheet](http://ndpsoftware.com/git-cheatsheet.html).

## `git commit`
---
Il comando `git commit` ci permette di _salvare_ del contenuto dall’index al branch locale.

![[git_commit.png|left|300]]Dopo aver creato il commit, l’`HEAD` e il puntatore al branch corrente puntano al nuovo commit. Anche il contenuto dell’index equivale al contenuto del commit.
 






![[git_commit_amend.png|right|300]]Con l’opzione `--amend` è possibile rimpiazzare facilmente l’ultimo commit con uno nuovo.






## `git switch` e `git checkout`
---
![[git_checkout.png|left|300]]Il comando `git switch` possiede un sottoinsieme delle funzionalità del comando `git checkout` ed è più semplice da utilizzare.

Permette di passare ad un nuovo branch semplicemente modificando l’HEAD (e di conseguenza il contenuto dell’index e dei file).

## `git merge`
---
Il comando `git merge` è utile per unire branch (o più in generale alberi) insieme.

Se i due branch non sono divergenti, il merge avviene in modo banale con un _fast-forward_: nessun ulteriore commit verrà cambiato, verrà solo modificato il puntatore del branch e l’HEAD.
Per forzare la creazione di un merge di commit occorre utilizzare l’opzione `--no-ff`.

In tutti gli altri casi, il merge può concludersi con successo, oppure possono avvenire conflitti. Per risolverli, git ci proporrà un’interfaccia simile alla seguente:

```console
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
=======
git makes conflict resolution easy.
>>>>>>> theirs:sample.txt
```

Una volta risolti tutti i conflitti è sufficiente fare un commit delle modifiche, concludendo quindi il merge.

![[git_merge.png|right|300]]La tecnica utilizzata per implementare la fusione di due rami è chiamata **3-way merge**: inizialmente, vengono considerati i commit `HEAD` dei due branch da unire e il primo commit comune a questi due (ovvero il commit da dove è iniziata la diramazione). A questo punto, git cercherà di identificare le parti dei file modificate nelle diverse diramazioni sfruttando i commit considerati, se viene riscontrato un cambiamento della stessa porzione di file in entrambe le diramazioni significa che si è verificato un conflitto, e quindi verrà richiesto l’intervento manuale dell’utente, altrimenti verranno uniti automaticamente i due rami in un commit di merge.

## `git reset`
---
![[git_reset.png]]

Il comando `git reset` reimposta il contenuto dei file nell’index (con l’opzione `--hard` della WD) all’ultimo commit puntato da `HEAD` o ad un altro commit.