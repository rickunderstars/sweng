# Introduzione
---
Il **Software Configuration Management** è l’insieme di pratiche che hanno l’obiettivo di rendere sistematico il processo di sviluppo, **tenendo traccia dei cambiamenti** in modo che il prodotto sia in ogni instante in uno **stato** (_configurazione_) **ben definito** e **permettendo di recuperare una versione precedente** in modo facile e veloce.

Le soluzioni di Software Configuration Management nascono dalla necessità di risolvere problemi complessi, purtroppo molto comuni, nel mondo dello sviluppo software.
Fra questi, abbiamo:

- pubblicare un _hotfix_ su una versione precedente a quella in cui si sta sviluppando. Può essere difficile localizzare le versioni vecchie, modificarle e ri-mappare le modifiche sulle versioni nuove;
- condividere lavori con altri gestendo accessi contemporanei e conflitti;
- stabilire la responsabilità di ciascuna linea di codice.

# Storia
---
Il *Configuration Management* nasce negli anni ’50 nell’ambito dell’industria aerospaziale. Alla fine degli anni ’70 inizia ad essere applicato all’ingegneria del software, prendendo il nome di *Software Configuration Management*.

Dato che l'SMC si pone come obiettivo quello di tenere traccia dei cambiamenti in modo che il prodotto sia in ogni istante in uno stato ben definito, vi è sempre la possibilità di controllare le revisioni degli _artifact_ e il risultato di tali revisioni.
Questo processo è molto utile per la generazione di un prodotto a partire da una configurazione ben determinata.

## Manufatti (*artifacts*)
---
Gli “oggetti” di cui si controlla l’evoluzione sono detti **manufatti** (o *configuration items*), generalmente dei file.
Se si cambia nome a un file è come eliminarne uno e partire da zero con uno nuovo. Originariamente, i tool tracciavano i file in maniera indipendente, senza un senso logico (una _configurazione_) comune.

![[configuration_scm.png]]

- anni ’80: **strumenti locali** (SCCS, …)
- anni ’90: **strumenti client-server centralizzati** (CVS, subversion, …)
- anni ’00: **strumenti distribuiti peer-to-peer** (git, mercurial, bazaar, …)

**git** nasce da un’esigenza di Linus Torvalds con il kernel Linux.

## Centralizzato vs Decentralizzato
---
![](https://youtu.be/4XpnKHJAok8)

Il mondo **open source** preferisce un **approccio decentralizzato al version control**.
Le motivazioni a riguardo sono principalmente:

- **possibilità di lavorare offline**;
- **maggiore veloce**, poiché la rete non fa più da _bottleneck_;
- supporto verso **diversi modi di lavorare**:
    - *simil centralizzato*, dove un repository viene considerata “di riferimento”;
    - *due peer* che collaborano direttamente;
    - *gerarchico a più livelli* (kernel Linux).

**Non c’è sincronizzazione automatica**, ma ci sono comandi espliciti per fare _merge_ tra repository remoti.
In git, per via della sua struttura modulare, è possibile utilizzare il proprio algoritmo _merge_ rispetto a quelli già inclusi.