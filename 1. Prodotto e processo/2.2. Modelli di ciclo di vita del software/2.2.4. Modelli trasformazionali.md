![[transf_models.png]]

Diametralmente opposti all’incubo del Pinball Life-Cycle troviamo i **modelli trasformazionali**. Tali modelli pretendono, infatti, di controllare tutti i passi e i procedimenti in **modo formale** e di estremizzare il numero di incrementi.

Partendo dai requisiti scritti in linguaggio informale, tali modelli procedono tramite una sequenza di **passi di trasformazione** dimostrabili tutti formalmente fino ad arrivare alla versione finale. Essi si basano infatti sull’idea che se le specifiche sono corrette e i passi di trasformazione sono dimostrati, allora ottengo un programma corretto, ovvero sicuramente aderente alle specifiche di cui sopra.
La presenza di una **storia delle trasformazioni applicate** permette un **rudimentale versioning**, con la **possibilità di tornare indietro a uno stato precedente** del progetto semplicemente annullando le ultime trasformazioni fatte.

![[formal_transformation.png]]

Ad ogni passo si ottiene quindi un **prototipo** che differisce dal prodotto finale per *efficienza* e *completezza*, ma che è possibile trasformare in un altro più efficiente e corretto. Non si tratta, tuttavia, di un processo totalmente automatico, in quanto ad ogni passo di *ottimizzazione* (ovvero applicazione di una trasformazione) è richiesto l’intervento di un decisore umano che scelga che cosa ottimizzare.

Viene quindi introdotto il concetto di **prova formale di correttezza** delle trasformazioni applicate. A causa di questo approccio molto rigido, questi modelli sono applicati nella realtà quasi solo negli ambienti di ricerca, oppure in progetti che includono sia hardware che software, come ad esempio lo sviluppo di processori.