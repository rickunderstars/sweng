Un **modello incrementale** è un particolare modello iterativo in cui **nelle iterazioni è inclusa anche la consegna**; questo permette di sviluppare il software poco a poco, rilasciandone gradualmente parti e componenti che costruiscano _incrementalmente_ il programma finito.

Si noti la differenza tra incrementale e iterativo; si può parlare infatti di:

- **implementazione iterativa**: dopo aver raccolto le specifiche e aver progettato il sistema, _iterativamente_ sviluppo i componenti, li integro nel prodotto finale, quindi consegno.
- **sviluppo incrementale**: l’iteratività interessa tutte le fasi, comprese quelle di specifica e realizzazione.

Lo sviluppo incrementale riconosce la criticità della variabilità delle richieste e la integra nel processo. La manutenzione non è quindi più una particolarità, ma è vista come normale e perfettamente integrata nel modello; in tal senso, la richiesta di una nuova feature o la correzione di un errore generano gli stessi step di sviluppo.

## Modello prototipale
___
Un particolare modello incrementale è il **modello prototipale**: viene introdotto il concetto di **prototipi usa e getta** (_throw away_), interi programmi che vengono costruiti e poi vengono buttati via.

Lo scopo del prototipo **non è consegnare un prodotto finito**, ma **ricevere feedback** dal cliente per essere sicuri di aver compreso a pieno i suoi requisiti, oppure **testare internamente** un’idea o uno strumento. Per questo motivo tali prototipi vengono costruiti non prendendo in considerazione come correttezza, pulizia del codice e leggibilità. I prototipi possono dunque essere:

- **pubblici**, per capire meglio i requisiti del cliente (vedi [L3](https://marcobuster.github.io/sweng/02_ciclo-vita/02_modelli-iterativi.html#b3));
- **privati**, chiamati _spike_ nel mondo agile, servono a esplorare nuovi strumenti, linguaggi e scelte per problemi difficili; inoltre, molto spesso succede che una volta programmata una soluzione, il problema viene compreso meglio (_“do it twice”_).

I prototipi pubblici possono generare la tentazione di consegnarli come prodotto finito, ma c’è l’enorme **rischio** di dover gestire in futuro un **software non mantenibile**, con codice illeggibile e con un altissimo debito tecnico.

**Legge di Boehm (L3)**

> La prototipizzazione **riduce significativamente** gli **errori** di analisi dei requisiti e di design, specialmente per le interfacce utente.

%% TODO: capire come reinterpretare questa parte
Il modello prototipale è iterativo perché ogni volta viene buttato il lavoro fatto e rieseguito da capo, questo fino ad avere una versione definitiva senza le problematiche incontrate che hanno causato l’eliminazione dei lavori precedenti.
%%

## Modello a fontana
___

![[fountain_model.png]]

Nel 1993 nasce, in contrapposizione al modello a cascata, il **modello a fontana**, che amplia il concetto di iterazione permettendo in qualunque momento di **tornare alla fase iniziale**: se ci si accorge della presenza di errori si torna all’inizio (_software pool_) e vengono ricontrollate tutte le fasi precedenti.
Ovviamente, questo **non implica l’eliminazione di tutto il lavoro fatto** fino a quel momento, quanto piuttosto la risoluzione degli errori con un approccio che parta, innanzitutto, dalla modifica dei requisiti (se possibile), delle specifiche e solo dopo del codice, evitando di rattoppare solo quest’ultimo alla "bell’e meglio" come nel modello _code-and-fix_.
Una volta risolto il problema alla radice si può risalire velocemente attraverso le altre fasi, mantenendo il lavoro già svolto, ma controllando che non si siano creati nuovi problemi nel mentre.

Così facendo si mantiene una pulizia del progetto in ogni sua fase, grazie alla **continua iterazione di esse** ogni volta che si incontra un problema.

Il modello a fontana è inoltre il primo in cui sono previste delle azioni dopo la consegna; dopo l’ultima fase (_programma in uso_), infatti, si aprono ancora due strade: **manutenzione** ed **evoluzione**.
La consegna del prodotto non è quindi più l’atto finale, ma solo un altro step del processo, ecco quindi che si aprono le porte ad una **visione incrementale** dello sviluppo software: risiede qua la definizione di modello incrementale, ovvero nell’**includere la consegna del progetto all’interno delle iterazioni**.

Anche qui, vengono **perdute le garanzie sui tempi di sviluppo**: una volta ritornati alla fase iniziale per risolvere un problema, non c’è la certezza di riuscire a raggiungere il punto da cui si è partiti, questo perché è possibile imbattersi in altri errori nelle fasi intermedie, costringendo un’iterazione continua per risolvere i diversi problemi. In questo modo, il software **perde completamente il concetto di linearità** e sarà impossibile prevederne i tempi di sviluppo, data la continua possibilità di evoluzione e manutenzione.

## I problemi dei modelli incrementali
___
Come già detto, **nessun modello è perfetto**, e anche i modelli incrementali soffrono di alcuni problemi.

Viene innanzitutto **complicato il lavoro di planning**, in quanto bisogna pianificare tutte le iterazioni e lo stato di avanzamento è meno visibile; inoltre, la ripetizione di alcune fasi richiede di avere sempre sul posto gli esperti in grado di eseguirle. Ad ogni iterazione, poi, è necessario revisionare ciò che è stato fatto, in un **processo che potrebbe non convergere mai a una versione finale**: è possibile che in un'iterazione venga tolta una parte perché complica l’avanzamento del progetto, oppure che il cliente cambi le sue richieste.

Ma cosa è un’iterazione? E quanto dura? Tagliare verticalmente sulle funzionalità non è  facile, soprattutto considerando che, quando viene consegnato, il prodotto dev’essere funzionante e progettato per consentire l’aggiunta di nuove features in modo semplice.

Ci sono dunque diversi rischi:

- voler aggiungere troppe funzionalità nella prima iterazione;
- overhead dovuto a troppe iterazioni;
- avere un eccessivo overlapping tra le iterazioni, quindi mancanza di tempo per recepire il feedback dell’utente (es. Microsoft Office 2020 e 2019 vengono sviluppati contemporaneamente).

(paper di approfondimento: [_From Waterfall to Iterative Development – A Challenging Transition for Project Managers_](https://bit.ly/3SYYs8y))

## Pinball Life-Cycle
---
![[pinball_life_cycle.png]]

Il _“modello meme”_ del **Pinball Life-Cycle**, creato da Ambler nel 1994 come **critica ai modelli incrementali**.
Viene messo in evidenza come l’ordine con cui vengono svolte le attività sia casuale, **incontrollabile**. Qualunque passo è possibile dopo qualunque altro, e non si possono imporre vincoli temporali, di conseguenza il processo è **non misurabile**.

Si tratta, ovviamente, di una visione eccessivamente pessimistica, ma spesso nelle aziende non specializzate l’iter di sviluppo assomiglia effettivamente a questo.